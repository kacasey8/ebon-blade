#include <nmmintrin.h> /* where intrinsics are defined */
#include <stdio.h>

// Autogenerated, do not edit. All changes will be undone.

void sgemm( int m_a, int n_a, float *A, float *B, float *C ) {
  __m128 tempB1, tempB2, tempB3, tempB4;
  __m128 tempA1, tempA2, tempA3, tempA4;
  __m128 tempC1, tempC2, tempC3, tempC4;
  //__m128 B1, B2, B3, B4;
  int m_a4 = m_a/4*4;
  int n_a4 = n_a/4*4;
  if (m_a4 == m_a && n_a4 == n_a) {
    for( int j = 0; j < m_a4; j += 4 ) {
      for( int i = 0; i < m_a4; i += 4 ) {
        tempC1 = _mm_loadu_ps(C+i+j*m_a); // load the 16 C values we will be using in the next loop
        tempC2 = _mm_loadu_ps(C+i+(j+1)*m_a);
        tempC3 = _mm_loadu_ps(C+i+(j+2)*m_a);
        tempC4 = _mm_loadu_ps(C+i+(j+3)*m_a);  
        for( int k = 0; k < n_a4; k += 4 ) {
          tempA1 = _mm_loadu_ps(A+i+k*m_a); // load the 16 values for A we will be using in this loop
          tempA2 = _mm_loadu_ps(A+i+(k+1)*m_a);
          tempA3 = _mm_loadu_ps(A+i+(k+2)*m_a);
          tempA4 = _mm_loadu_ps(A+i+(k+3)*m_a);

          tempB1 = _mm_load1_ps(B+j+k*m_a); // load 4 B values [1, 1, 1, 1]
          tempB2 = _mm_load1_ps(B+j+(k+1)*m_a); // [5, 5, 5, 5]
          tempB3 = _mm_load1_ps(B+j+(k+2)*m_a); // [9, 9, 9, 9]
          tempB4 = _mm_load1_ps(B+j+(k+3)*m_a); // [13, 13, 13, 13]

          tempC1 += _mm_mul_ps(tempA1, tempB1); // use the 16 A values, 4 B values
          tempC1 += _mm_mul_ps(tempA2, tempB2);
          tempC1 += _mm_mul_ps(tempA3, tempB3);
          tempC1 += _mm_mul_ps(tempA4, tempB4);

          tempB1 = _mm_load1_ps(B+j+1+k*m_a); // load 4 new B values
          tempB2 = _mm_load1_ps(B+j+1+(k+1)*m_a); 
          tempB3 = _mm_load1_ps(B+j+1+(k+2)*m_a); 
          tempB4 = _mm_load1_ps(B+j+1+(k+3)*m_a); 

          tempC2 += _mm_mul_ps(tempA1, tempB1);
          tempC2 += _mm_mul_ps(tempA2, tempB2);
          tempC2 += _mm_mul_ps(tempA3, tempB3);
          tempC2 += _mm_mul_ps(tempA4, tempB4);

          tempB1 = _mm_load1_ps(B+j+2+k*m_a);
          tempB2 = _mm_load1_ps(B+j+2+(k+1)*m_a); 
          tempB3 = _mm_load1_ps(B+j+2+(k+2)*m_a); 
          tempB4 = _mm_load1_ps(B+j+2+(k+3)*m_a); 

          /*tempC3 += _mm_mul_ps(tempA1, tempB1);
          tempC3 += _mm_mul_ps(tempA2, tempB2);
          tempC3 += _mm_mul_ps(tempA3, tempB3);
          tempC3 += _mm_mul_ps(tempA4, tempB4);*/

          tempC3 =        // a nested function call, does what
          _mm_add_ps(     // 4 lines commented code above does
            tempC3,       // seems to generate amazing speed
            _mm_add_ps(   // increase (1 Gflop/s)
              _mm_mul_ps(tempA1, tempB1), 
              _mm_add_ps(
                _mm_mul_ps(tempA2, tempB2),
                _mm_add_ps(
                  _mm_mul_ps(tempA3, tempB3), 
                  _mm_mul_ps(tempA4, tempB4)))));

          tempB1 = _mm_load1_ps(B+j+3+k*m_a);
          tempB2 = _mm_load1_ps(B+j+3+(k+1)*m_a); 
          tempB3 = _mm_load1_ps(B+j+3+(k+2)*m_a); 
          tempB4 = _mm_load1_ps(B+j+3+(k+3)*m_a); 

          tempC4 += _mm_mul_ps(tempA1, tempB1);
          tempC4 += _mm_mul_ps(tempA2, tempB2);
          tempC4 += _mm_mul_ps(tempA3, tempB3);
          tempC4 += _mm_mul_ps(tempA4, tempB4);

          /*tempC4 =         // a replica of the mod made on tempC3
          _mm_add_ps(      // appears to conteract the 
            tempC4,        // benefit
            _mm_add_ps(
              _mm_mul_ps(tempA1, tempB1), 
              _mm_add_ps(
                _mm_mul_ps(tempA2, tempB2),
                _mm_add_ps(
                  _mm_mul_ps(tempA3, tempB3), 
                  _mm_mul_ps(tempA4, tempB4)))));*/
        }
        _mm_storeu_ps(C+i+j*m_a, tempC1); // store the 16 C values we calculated in the above loop
        _mm_storeu_ps(C+i+(j+1)*m_a, tempC2);
        _mm_storeu_ps(C+i+(j+2)*m_a, tempC3);
        _mm_storeu_ps(C+i+(j+3)*m_a, tempC4);
      }
    }
  } else {
    for( int k = 0; k < n_a; k++ ) {
      for( int j = 0; j < m_a; j++ ) {
        tempB1 = _mm_load1_ps(B+j+k*m_a); // load B[j + k*m_a] into all 4
        for( int i = 0; i < m_a4; i += 4 ) {
          tempA1 = _mm_loadu_ps(A+i+k*m_a); // load A[i + k*m_a], A[i+1+k*m_a],
          tempC1 = _mm_loadu_ps(C+i+j*m_a); // load C[i+j*m_a)], C[i+1+j*m_a], etc.
          _mm_storeu_ps(C+i+j*m_a, _mm_add_ps(tempC1, _mm_mul_ps(tempA1, tempB1))); 
          //C[i+j*m_a] += A[i+k*m_a] * B[j+k*m_a];
        }
        for( int i = m_a4; i < m_a; i++) {
          C[i+j*m_a] += A[i+k*m_a] * B[j+k*m_a];
        }
      }
    }
  }
}

void sgemm1( int m_a, int n_a, float *A, float *B, float *C ) {
  __m128 tempB1, tempB2, tempB3, tempB4;
  __m128 tempA1, tempA2, tempA3, tempA4;
  __m128 tempC1, tempC2, tempC3, tempC4;
  __m128 B1, B2, B3, B4;
  int m_a4 = m_a/4*4;
  int n_a4 = n_a/4*4;
  if (m_a4 == m_a && n_a4 == n_a) {
    for( int j = 0; j < m_a; j += 4 ) {
      for( int i = 0; i < m_a; i += 4 ) {
        tempC1 = _mm_loadu_ps(C+i+j*m_a); // load the 16 C values we will be using in the next loop
        tempC2 = _mm_loadu_ps(C+i+(j+1)*m_a);
        tempC3 = _mm_loadu_ps(C+i+(j+2)*m_a);
        tempC4 = _mm_loadu_ps(C+i+(j+3)*m_a);
        for( int k = 0; k < n_a; k += 4 ) {
          tempA1 = _mm_loadu_ps(A+i+k*m_a); // load the 16 values for A we will be using in this loop
          tempA2 = _mm_loadu_ps(A+i+(k+1)*m_a);
          tempA3 = _mm_loadu_ps(A+i+(k+2)*m_a);
          tempA4 = _mm_loadu_ps(A+i+(k+3)*m_a);

          B1 = _mm_loadu_ps(B+j+k*m_a); // load the 16 values for B we will be using in this loop [1, 2, 3, 4]
          B2 = _mm_loadu_ps(B+j+(k+1)*m_a); // [5, 6, 7, 8]
          B4 = _mm_loadu_ps(B+j+(k+3)*m_a); // [13, 14, 15, 16]

          tempB1 = _mm_shuffle_ps(B1, B1, 0); // shuffle tactics, will look like [1, 1, 1, 1]
          tempB2 = _mm_shuffle_ps(B2, B2, 0); // [5, 5, 5, 5]
          tempB3 = _mm_shuffle_ps(B3, B3, 0); // [9, 9, 9, 9]
          tempB4 = _mm_shuffle_ps(B4, B4, 0); // [13, 13, 13, 13]

          tempC1 += _mm_mul_ps(tempA1, tempB1); 
          tempC1 += _mm_mul_ps(tempA2, tempB2);
          tempC1 += _mm_mul_ps(tempA3, tempB3);
          tempC1 += _mm_mul_ps(tempA4, tempB4);

          tempB1 = _mm_shuffle_ps(B1, B1, 0x55);
          tempB2 = _mm_shuffle_ps(B2, B2, 0x55);
          tempB3 = _mm_shuffle_ps(B3, B3, 0x55);
          tempB4 = _mm_shuffle_ps(B4, B4, 0x55);

          tempC2 += _mm_mul_ps(tempA1, tempB1);
          tempC2 += _mm_mul_ps(tempA2, tempB2);
          tempC2 += _mm_mul_ps(tempA3, tempB3);
          tempC2 += _mm_mul_ps(tempA4, tempB4);

          tempB1 = _mm_shuffle_ps(B1, B1, 0xAA);
          tempB2 = _mm_shuffle_ps(B2, B2, 0xAA);
          tempB3 = _mm_shuffle_ps(B3, B3, 0xAA);
          tempB4 = _mm_shuffle_ps(B4, B4, 0xAA);

          tempC3 += _mm_mul_ps(tempA1, tempB1);
          tempC3 += _mm_mul_ps(tempA2, tempB2);
          tempC3 += _mm_mul_ps(tempA3, tempB3);
          tempC3 += _mm_mul_ps(tempA4, tempB4);

          tempB1 = _mm_shuffle_ps(B1, B1, 0xFF);
          tempB2 = _mm_shuffle_ps(B2, B2, 0xFF);
          tempB3 = _mm_shuffle_ps(B3, B3, 0xFF);
          tempB4 = _mm_shuffle_ps(B4, B4, 0xFF);

          tempC4 += _mm_mul_ps(tempA1, tempB1);
          tempC4 += _mm_mul_ps(tempA2, tempB2);
          tempC4 += _mm_mul_ps(tempA3, tempB3);
          tempC4 += _mm_mul_ps(tempA4, tempB4);
        }
        _mm_storeu_ps(C+i+j*m_a, tempC1); // store the 16 C values we calculated in the above loop
        _mm_storeu_ps(C+i+(j+1)*m_a, tempC2);
        _mm_storeu_ps(C+i+(j+2)*m_a, tempC3);
        _mm_storeu_ps(C+i+(j+3)*m_a, tempC4);
      }
    }
  } else {
    for( int k = 0; k < n_a; k++ ) {
      for( int j = 0; j < m_a; j++ ) {
        tempB1 = _mm_load1_ps(B+j+k*m_a); // load B[j + k*m_a] into all 4
        for( int i = 0; i < m_a4; i += 4 ) {
          tempA1 = _mm_loadu_ps(A+i+k*m_a); // load A[i + k*m_a], A[i+1+k*m_a],
          tempC1 = _mm_loadu_ps(C+i+j*m_a); // load C[i+j*m_a)], C[i+1+j*m_a], etc.
          _mm_storeu_ps(C+i+j*m_a, _mm_add_ps(tempC1, _mm_mul_ps(tempA1, tempB1))); 
          //C[i+j*m_a] += A[i+k*m_a] * B[j+k*m_a];
        }
        for( int i = m_a4; i < m_a; i++) {
          C[i+j*m_a] += A[i+k*m_a] * B[j+k*m_a];
        }
      }
    }
  }
}
  B3 = _mm_loadu_ps(B+j+(k+2)*m_a); // [9, 10, 11, 12]
        